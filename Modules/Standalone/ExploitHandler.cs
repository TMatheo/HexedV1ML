using ExitGames.Client.Photon;
using LUXED.Extensions;
using LUXED.Wrappers;
using System;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

namespace LUXED.Modules.Standalone
{
    internal class ExploitHandler
    {
        public static bool isPortalKOSEnabled = false;
        public static bool isVoiceDistortionEnabled = false;
        public static string PortalID = "";
        public static string E1 = "AAAAAGfp+Lv2GRkA+MrI08yxTwBkxqwATk9LRU0wTk9LM00wTg==";
        public static IEnumerator VoiceDistortion()
        {
            isVoiceDistortionEnabled = true;
            while (isVoiceDistortionEnabled)
            {
                if (GameUtils.IsInWorld())
                {
                    byte[] array = Convert.FromBase64String(E1);
                    byte[] trimmedArray = new byte[array.Length - 4];
                    byte[] bytes = BitConverter.GetBytes(Networking.GetServerTimeInMilliseconds());
                    Buffer.BlockCopy(array, 4, trimmedArray, 0, array.Length - 4);
                    Buffer.BlockCopy(bytes, 0, trimmedArray, 0, 4);
                    RaiseEventOptions raiseEventOptions = new RaiseEventOptions
                    {
                        field_Public_EventCaching_0 = 0,
                        field_Public_ReceiverGroup_0 = 0
                    };
                    PhotonHelper.OpRaiseEvent(1, trimmedArray, raiseEventOptions, default(SendOptions));
                }
                yield return new WaitForSeconds(0.1f);
            }
        }
        public static IEnumerator PortalKOS(VRC.Player player)
        {
            isPortalKOSEnabled = true;

            while (PortalID == null) yield return new WaitForEndOfFrame();

            while (isPortalKOSEnabled && player != null && GameUtils.IsInWorld())
            {
                PhotonHelper.RaisePortalCreate(PortalID, player.transform.position, -1);
                yield return new WaitForSeconds(3f);
            }
        }

        public static void ListenPlayer(VRC.Player player, bool state)
        {
            if (state)
            {
                player.GetVRCPlayerApi().SetVoiceDistanceFar(float.PositiveInfinity);
            }
            else
            {
                player.GetVRCPlayerApi().SetVoiceDistanceFar(25); // player.GetVRCPlayer().prop_PlayerAudioManager_0.field_Private_Single_1
            }
        }

        public static void RepeatVoiceEvents(byte[] data)
        {
            if (data == null || data.Length < 8) return; // Ensure data is long enough
            int actorId = GameHelper.VRCNetworkingClient.GetCurrentPlayer().ActorID();
            Buffer.BlockCopy(BitConverter.GetBytes(actorId), 0, data, 0, 4);
            int serverTime = GameHelper.VRCNetworkingClient.prop_LoadBalancingPeer_0.ServerTimeInMilliSeconds;
            Buffer.BlockCopy(BitConverter.GetBytes(serverTime), 0, data, 4, 4);
            RaiseEventOptions raiseEventOptions = new RaiseEventOptions
            {
                field_Public_EventCaching_0 = 0,    // No caching
                field_Public_ReceiverGroup_0 = 0     // Others
            };
            //PhotonHelper.OpRaiseEvent(1, data, raiseEventOptions, default(SendOptions));
        }

        public static bool isStaticChatboxEnabled = false;
        public static IEnumerator StaticChatbox(string Message)
        {
            if (Message == null || isStaticChatboxEnabled) yield break;

            isStaticChatboxEnabled = true;

            while (isStaticChatboxEnabled)
            {
                if (GameUtils.IsInWorld()) PhotonHelper.RaiseChatMessage(Message);

                yield return new WaitForSeconds(3f);
            }
        }

        public static bool isMediaChatboxEnabled = false;

        public static IEnumerator MediaChatbox()
        {
            if (isMediaChatboxEnabled) yield break;

            isMediaChatboxEnabled = true;

            while (isMediaChatboxEnabled)
            {
                if (GameUtils.IsInWorld())
                {
                    Process firefox = Process.GetProcessesByName("firefox")
                        .FirstOrDefault(p => !string.IsNullOrWhiteSpace(p.MainWindowTitle) && !p.MainWindowTitle.Contains("Mozilla Firefox"));

                    if (firefox != null && firefox.MainWindowTitle != null)
                    {
                        PhotonHelper.RaiseChatMessage($"🌐 {firefox.MainWindowTitle}");
                    }
                }

                yield return new WaitForSeconds(3f);
            }

            isMediaChatboxEnabled = false;
        }


        public static bool isAlwaysTypingEnabled = false;
        public static IEnumerator AlwaysTyping()
        {
            if (isAlwaysTypingEnabled) yield break;

            isAlwaysTypingEnabled = true;

            while (isAlwaysTypingEnabled)
            {
                if (GameUtils.IsInWorld()) PhotonHelper.RaiseTypingIndicator(0);
                yield return new WaitForSeconds(1f);
            }

            isAlwaysTypingEnabled = false;
        }

        public static bool isUdonSpamming = false;
        public static IEnumerator UdonSpam(VRC.Player player)
        {
            if (isUdonSpamming) yield break;

            isUdonSpamming = true;

            UdonBehaviour[] allEvents = UnityEngine.Object.FindObjectsOfType<UdonBehaviour>();

            while (isUdonSpamming && player != null && GameUtils.IsInWorld())
            {
                foreach (UdonBehaviour behaviour in allEvents)
                {
                    foreach (string UdonEvent in behaviour._eventTable.Keys)
                    {
                        if (!UdonEvent.StartsWith("_") && player != null) PhotonHelper.SendUdonRPC(behaviour, UdonEvent, player);
                    }
                }

                yield return new WaitForSeconds(1f);
            }

            isUdonSpamming = false;
        }

        public static bool isCollapse = false;
        public static IEnumerator Collapse(VRC.Player player)
        {
            isCollapse = true;

            var pickups = ItemHelper.GetAllPickups().Where(x => x.GetComponent<Collider>() != null && x.GetComponent<Collider>().enabled || x.GetComponentInChildren<Collider>() != null && x.GetComponentInChildren<Collider>().enabled);

            while (isCollapse && player != null && GameUtils.IsInWorld())
            {
                for (int i = 0; i < 20; i++)
                {
                    foreach (var pickup in pickups)
                    {
                        float yOffset = (i - 1) * 0.05f;

                        ItemHelper.TakeOwnershipIfNecessary(pickup.gameObject);
                        pickup.transform.position = player.transform.position + new Vector3(0, -0.1f + yOffset, 0);
                        pickup.transform.rotation = Quaternion.Euler(0, 0, 0);
                    }

                    yield return new WaitForEndOfFrame();
                }

                yield return new WaitForSeconds(0.1f);

                foreach (var pickup in pickups)
                {
                    ItemHelper.TakeOwnershipIfNecessary(pickup.gameObject);
                    pickup.transform.position = UnityUtils.InfPosition.INFBypass;
                    pickup.transform.rotation = Quaternion.Euler(0, 0, 0);
                }

                yield return new WaitForSeconds(0.1f);
            }

            isCollapse = false;
        }

        public static bool isMemoryViolation = false;
        public static IEnumerator MemoryViolation()
        {
            isMemoryViolation = true;

            while (isMemoryViolation && GameUtils.IsInWorld())
            {
                UdonBehaviour[] allEvents = UnityEngine.Object.FindObjectsOfType<UdonBehaviour>();

                foreach (UdonBehaviour behaviour in allEvents)
                {
                    ItemHelper.TakeOwnershipIfNecessary(behaviour.gameObject);
                    behaviour.SyncMethod = Networking.SyncType.Continuous;

                    yield return new WaitForEndOfFrame(); // Delay to not cause unusual client behaviour
                }

                yield return new WaitForSeconds(1f); // Delay to not cause unusual client behaviour
            }

            isMemoryViolation = false;
        }
    }
}

